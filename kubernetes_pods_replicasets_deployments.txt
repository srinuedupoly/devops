pods:
-------
====================
In Kubernetes, a Pod is the smallest deployable unit that represents a single instance of a running process in a cluster. A Pod can contain one or more containers that are tightly coupled and share the same network namespace, storage, and other resources. The primary purpose of a Pod is to provide a way to deploy and manage containers together on the same host.

Here's a simple example of a Pod definition in YAML:
====================
1.	Containers are encapsulated in Kubernetes object known as pod
2.	Pod is a single instance of an application
3.	Pod is a smallest object in Kubernetes
4.	Single pod can have multi container (helper container like init container/sidecar container)- share the same network space and volumes space



cat demo-pod.yaml 

apiVersion: v1

kind: Pod

metadata:

  name: nginx

spec:

  containers:

  - name: nginx

    image: nginx:1.14.2

    ports:

    - containerPort: 80
----------------------------
Explanation of key components:

apiVersion: Specifies the API version being used. In this case, it's v1, the core Kubernetes API version.

kind: Specifies the type of Kubernetes resource, and in this case, it's a Pod.

metadata: Contains information about the Pod, such as its name.

spec: Describes the specification of the desired state for the Pod.

containers: An array of containers to run within the Pod.

name: The name of the container, in this case, nginx-container.

image: The Docker image to use for the container, in this case, the latest version of NGINX.

ports: Specifies the ports to open on the container.



-----------------------------
kubectl apply -f demo-pod.yaml
kubectl get pods
kubectl get pods -o wide
kubectl describe po <pod name>
kubectl logs <pod name>
kubectl delete -f demo-pod.yaml
==========================================
Replication controller/Replica set

Replica set is advanced for replication controller

Controllers are brain behind kubernetes
These are the processes that monitor Kubernetes objects and respond accordingly
For high availability â€“ controller helps to run multiple instances , if once pod fails , application will use other pod 
Even if one existing pod fails , it will create another one in parallel  
Replication controller make sure that desirable pods to run at all times
Replication controller helps in load balancing and scaling 


cat demo-rc.yaml 

apiVersion: apps/v1

kind: ReplicaSet

metadata:

  name: nginx-replicaset

spec:

  replicas: 5

  selector:

    matchLabels:

      app: nginx

  template:

    metadata:

      labels:

        app: nginx

    spec:

      containers:

      - name: nginx-container

        image: nginx:latest

        ports:

        - containerPort: 80
------------------------------------------
kubectl apply -f demo-rc.yaml
kubectl get pods
kubectl get pods -o wide
kubectl describe po <pod name>
kubectl logs <pod name>

kubectl get rs

delete a pod and check the status
kubectl delete po <pod name>

kubectl get po
kubectl delete -f demo-rc.yaml


=============================================================
In Kubernetes, a Deployment is a resource object used to manage the deployment and scaling of a set of Pods. Deployments provide a declarative way to define the desired state of your application and manage updates to it. They are a higher-level abstraction over ReplicaSets, making it easier to handle rolling updates, scaling, and rollback operations.

Here is an example of a simple Deployment YAML file:


cat demo-deploy.yaml 

apiVersion: apps/v1

kind: Deployment

metadata:

  name: nginx-deployment

spec:

  replicas: 5

  selector:

    matchLabels:

      app: nginx

  template:

    metadata:

      labels:

        app: nginx

    spec:

      containers:

      - name: nginx-container

        image: nginx:latest

        ports:

        - containerPort: 80
-----------------------------------------

Explanation of key components:

apiVersion: Specifies the API version being used. In this case, it's apps/v1, the API version for Deployments.

kind: Specifies the type of Kubernetes resource, and in this case, it's a Deployment.

metadata: Contains information about the Deployment, such as its name.

spec: Describes the specification of the desired state for the Deployment.

replicas: Specifies the desired number of replicas (Pods) to run.

selector: Defines how the Deployment identifies which Pods to manage.

template: Defines the Pod template that will be used to create new Pods.

metadata: Labels assigned to the Pods.

spec: Describes the specification of the Pod template.

containers: Specifies the containers within the Pod.

name: The name of the container.

image: The Docker image to use for the container.

ports: Specifies the ports to open on the container.


------------------------------------------
kubectl apply -f demo-deploy.yaml
kubectl get deployments
kubectl get rs
kubectl get pods
kubectl get pods -o wide
kubectl describe po <pod name>
kubectl logs <pod name>

delete a pod and check the status
kubectl delete po <pod name>

kubectl get po

edit deployment file and change the number of replicas
kubectl edit rs <replica set name>
# change the replicas to 5

kubectl get pods

kubectl delete -f demo-deploy.yaml






=============================================================





